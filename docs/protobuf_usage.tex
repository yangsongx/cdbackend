\documentclass[a4paper]{article}
\title{\kai{服务器RPC机制protobuf}}
\author{CareDear Service Team}
\usepackage{fontspec,xunicode,xltxtra,makeidx,xecolor}
\usepackage{color,listings,tabularx,amsfonts}
\usepackage{amssymb}
\usepackage{titlesec}
\usepackage{epigraph}
\usepackage{soul}
\usepackage[bookmarks=true,pdfborder={0 0 0}]{hyperref}
\setmainfont{WenQuanYi Micro Hei}
\setsansfont{WenQuanYi Micro Hei}
\setmonofont{WenQuanYi Micro Hei}

\newcommand\vtextvisiblespace[1][.4em]{%
  \mbox{\kern.06em\vrule height.5ex}%
  \vbox{\hrule width#1}%
  \hbox{\vrule height.5ex}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5\baselineskip}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip=0pt plus 1pt minus 0.1pt
\newcommand\fontnamekai{KaiTi}
\newfontinstance\KAI {\fontnamekai}
\newcommand{\kai}[1]{{\KAI#1}}
\newcommand\fontnamexkai{STXingkai}
\newfontinstance\XKAI {\fontnamexkai}
\newcommand{\xkai}[1]{{\XKAI#1}}
\newcommand\fontnamelisu{LiSu}
\newfontinstance\LISU {\fontnamelisu}
\newcommand{\lisu}[1]{{\LISU#1}}
%listing global settings
\lstset{basicstyle=\scriptsize,frame=lines}

%some global color
\definecolor{light-gray}{rgb}{0.87,0.87,0.87}
\definecolor{light-yellow}{rgb}{0.88,0.92,0.48}
\definecolor{mygreen}{rgb}{0.63,1,0.35}

%complicated def
\lstnewenvironment{myjavacode}[1][]
      {\lstset{language=Java}\lstset{escapeinside={(*@}{@*)},
       basicstyle=\footnotesize\ttfamily,
       numbers=left,numberstyle=\scriptsize,stepnumber=1,numbersep=5pt,
       breaklines=true,
       %firstnumber=last,
           %frame=tblr,
           framesep=5pt,
           showstringspaces=false,
           keywordstyle=\itshape\color{blue},
          %identifierstyle=\ttfamily,
           stringstyle=\xecolor{maroon},
        commentstyle=\color{black},
        rulecolor=\color{black},
        xleftmargin=0pt,
        xrightmargin=0pt,
        aboveskip=\medskipamount,
        belowskip=\medskipamount,
               backgroundcolor=\color{white}, #1
}}
{}

%\titleformat{\section}[block]{\kai}{\thesection}{10pt}{}
\makeindex
\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
\kai{本文档介绍Google的服务器间RPC机制－protobuf}
\end{abstract}

%%DO NOT MODIFY ANY TEXT OF BELOW BEGIN-END marker!!!!

\section{简介}
这里暂时以Google的protobuf-2.5.0版本为基准，protobuf的完整代码包，可以在Caredear服务器的backend/3rd\_party/protobuf-2.5.0/目录下找到。

代码编译出的结果是一个编译解析器(protoc)，目前支持下面三种语言的绑定：

\begin{enumerate}
 \item C++
 \item Python
 \item Java
\end{enumerate}

Figure-\ref{figProtoc}是protobuf处理流程，其编译器(protoc)将会把交互消息定义.proto文件(IDL)，按照用户指定语言绑定来自动生成相对应代码。
\begin{figure}
\caption{protoc的使用原理}\label{figProtoc}
\centering
\includegraphics[scale=0.80]{protoc.eps}
\end{figure}

各个语言间可以无缝的交互数据，而不必再自己手动地编写代码去解析，或者组装数据包。

比如Figure-\ref{figProtocCode}是一个更详细的例子，通过protoc生成的代码文件中，已经自动包含了数据的组包和解包的逻辑，用户不应该修改这些自动生成的源代码文件，而应该在自己的源文件中调用自动生成的这些代码接口。

从Figure-\ref{figProtocCode}可看出，当在.proto文件中定义完数据域后，protoc会在各自语言绑定中完成setXXX和getXXX接口与实现。

.proto文件中的package命令转换到C++代码将是namespace，而在Java代码中则就是Java程序的package。

\section{Java的绑定}
目前默认下，protoc只会生成Java代码，而Java运行需要的库，则要求使用Apache Maven包(mvn命令行程序)来编译。

在Ubuntu系统上，使用apt-get install mvn既可得到mvn程序，再使用下面命令：

\begin{lstlisting}
protobuf/java $ mvn install
protobuf/java $ mvn package
\end{lstlisting}

这将会在java/目录下生成target/protobuf-java-2.5.0.jar包，Java语言程序编译和运行，都需要依赖该包。

和C++绑定不同，Java生成代码中的set()/get()并不是直接定义的，它是通过Builder()来间接实现的：
\begin{lstlisting}
TokenMessage.TokenRequest.Builder b =
    TokenMessage.TokenRequest.newBuilder();
b.setUid("");
b.setAppid("");
...
TokenMessage.TokenRequest req = b.build();
\end{lstlisting}

命令行运行Java程序的方法：
\begin{lstlisting}[frame=none]
$ java -classpath protobuf-java-2.5.0.jar:. Main
\end{lstlisting}


\section{使用示例}
在caredear服务器代码的backend/docs/samplecode/目录下，是一个演示Java前端和C++后端交换数据的流程。

Figure-\ref{figProtocCode}演示了两个模块间消息数据交换的定义，以及由TokenMessage.proto的IDL转换成各自语言绑定的过程。

\begin{figure}
\caption{基于protobuf协议的跨语言消息数据定义流程}\label{figProtocCode}
\centering
\includegraphics[scale=0.70]{protoccode.eps}
\end{figure}

由于protobuf只是负责数据封装和解析，如何传输并没有做具体要求。

所以对于跨机器情况下，我们通常可以将数据对象序列化后，转换成Byte类型，再加上leading length的字段，表明整个数据的有效长度。

这样接收终端会根据这个leading length知道整个数据长度，然后按需读取数据，在使用protobuf提供的接口进行数据解析。

Figure-\ref{figProtocCodeJandC}演示了两端数据交换时需要的一些代码调用。

\begin{figure}
\caption{C++和Java数据交换代码示例}\label{figProtocCodeJandC}
\centering
\includegraphics[scale=0.70]{protobufsamplecode.eps}
\end{figure}

\section{IDL语法}
目前protobuf支持的数据类型定义有：

\bgroup
\def\arraystretch{1.15}
\begin{tabular}{|l|l|l|l|}
\hline
{.ptoro数据类型} & {C++类型} & {Java类型} & {说明} \\
\hline
{int32} & {int} & {int} & {根据实际大小变长实现}\\
{fixed32} & {int} & {int} & {定长的4字节大小}\\
{string} & {std::string} & {Java.lang.String} & {字符串}\\
{bool} 　& {bool} & {Boolean} & {布尔值}\\
\hline
\end{tabular}
\egroup

复杂.proto文件数据定义时，若需要引用其它的.proto文件，则可以使用import关键词：
\begin{lstlisting}[frame=none]
import "other/other_def.proto"
\end{lstlisting}


\section{关于本文档}
介绍protobuf话题的文档置于backend/docs/目录下。

Figure-\ref{figProtocCode}和Figure-\ref{figProtocCodeJandC}描述的代码，位于backend/docs/samplecode/目录下。

%% BEGIN CD-Specific CHANGE

%% END CD-Specific CHANGE



%fell free to modify below items...
\begin{thebibliography}{99}
\bibitem{refMemcach}memcached: {\em http://memcached.org}, a high-performance cache system.
\bibitem{reflibevent} Libevent: {\em http://libevent.org}, an open source event notification library.
\bibitem{refProtobuf}Protobuf: {\em  http://code.google.com/p/protobuf/}, Google protobuf官方网址.
\end{thebibliography}

\end{document}

